                        StringBuilder fittedKnotCounts = new StringBuilder();

                        // bool isRoot = parentTable[targetNode] == null;
                        //
                        // // We want 0.1mm precision for translation.
                        // // We give roots a range of ~ 100x100 meter,
                        // // and children a range of ~ 3x3 meter.
                        // // TODO: Compute bits for quaternion.
                        // var quantBits = curveKind switch
                        // {
                        //     AnimationChannelTarget.PathEnum.translation => isRoot ? 20 : 15,
                        //     AnimationChannelTarget.PathEnum.rotation => 10,
                        //     AnimationChannelTarget.PathEnum.scale => 10,
                        //     AnimationChannelTarget.PathEnum.weights => 10,
                        //     _ => throw new ArgumentOutOfRangeException()
                        // };
                        //
                        // var quantErrorBits = curveKind switch
                        // {
                        //     AnimationChannelTarget.PathEnum.translation => isRoot ? 8 : 4,
                        //     _ => 4
                        // };
                        //
                        // var qScale = curveKind switch
                        // {
                        //     AnimationChannelTarget.PathEnum.translation => 10, // cm to mm
                        //     _ => 1 << quantBits
                        // };
                        //
                        // var qMin = -(1 << (quantErrorBits - 1));
                        // var qMax = (1 << (quantErrorBits - 1)) - 1;

#if false

                        var segmentsCount = 0;

                        for (int axis = 0; axis < dimension; ++axis)
                        {
                            var curvePoints = curvesPoints[axis];

                            var segments = CubicRegression.FitCubics(curvePoints, qScale, qMin, qMax);

                            segmentsCount += segments.Count;

                            var fittedPoints = new Point[pointCount];

                            int index = 0;

                            sbyte[] quantErrors = ArrayPool<sbyte>.Shared.Rent(pointCount);

                            var valueFloats = MemoryMarshal.Cast<byte, float>(valuesSpan);

                            foreach (var (segment, stop) in segments)
                            {
                                while (index < stop)
                                {
                                    var cp = curvePoints[index];
                                    var py = segment.AbsEvaluate(cp.X);
                                    var qError = Math.Round((py - cp.Y) * qScale);
                                    Debug.Assert(qError >= qMin && qError <= qMax);

                                    valueFloats[index * dimension + axis] = (float) (py + qError / qScale);

                                    quantErrors[index] = (sbyte)qError;

                                    var vx = xOffset + index * pixelsPerFrame;
                                    var vy = yOffset + (py - yStarts[axis]) * yScales[axis] * yHeight;
                                    fittedPoints[index++] = new Point(vx, vy);
                                }
                            }

                            var quantData = MemoryMarshal.AsBytes(new Span<sbyte>(quantErrors));
                            zipStream.Write(quantData);

                            /*
                            var polys = Solvers.FitBestPolynomial(curvePoints, precision);


                            int index = 0;

                            foreach (var (stop, poly) in polys)
                            {
                                while (index < stop)
                                {
                                    var x = curvePoints[index].X;
                                    var y = alglib.barycentriccalc(poly, x);

                                    var vx = xOffset + index * pixelsPerFrame;
                                    var vy = yOffset + (y - yStarts[axis]) * yScales[axis] * yHeight;
                                    fittedPoints[index++] = new Point(vx, vy);
                                }
                            }
                            */

                            var dots = Curve.ToPointsGeometry(fittedPoints, curveThickness * 2);

                            curvesCanvas.Children.Add(new PathShape
                            {
                                Data = dots,
                                Height = curveHeight,
                                Fill = curveColors[axis],
                                ClipToBounds = false,
                                IsHitTestVisible = false
                            });
                        }

                        // one byte per segment-index (todo: fit per 256 samples)
                        fittedKnotCounts.Append(segmentsCount * 4);
                        outputByteCount += segmentsCount + segmentsCount * 16;
#endif

#if false
                        for (int axis = 0; axis < dimension; ++axis)
                        {
                            var inputPoints = visualPoints[axis];

                            alglib.spline1dfit(
                                inputPoints.Select(p => p.X).ToArray(),
                                inputPoints.Select(p => p.Y).ToArray(),
                                8, 1e-4,
                                out var spline, out var report);

                            alglib.spline1dunpack(spline, out var count, out var curvePoints);

                            var controlPointCount = curvePoints.GetLength(0);

                            fittedPointCounts.Append(controlPointCount);
                            fittedPointCounts.Append(' ');

                            var fittedPoints = new Point[pointCount];
                            var firstX = inputPoints[0].X;
                            var lastX = inputPoints[pointCount - 1].X;

                            for (int i = 0; i < pointCount; ++i)
                            {
                                var x = inputPoints[i].X;
                                var y = alglib.spline1dcalc(spline, x);
                                fittedPoints[i] = new Point(x, y);
                            }

                            var line = Curve.ToLineGeometry(fittedPoints);

                            curvesCanvas.Children.Add(new PathShape
                            {
                                Data = line,
                                Height = curveHeight,
                                Stroke = curveColors[axis],
                                StrokeThickness = curveThickness * 2,
                                Opacity = 0.5,
                                ClipToBounds = false,
                                IsHitTestVisible = false
                            });

                            var points = new Point[controlPointCount + 1];

                            for (int i = 0; i < controlPointCount; i++)
                            {
                                var x = curvePoints[i, 0];
                                var y = alglib.spline1dcalc(spline, x);
                                points[i] = new Point(x, y);

                                if (i == controlPointCount - 1)
                                {
                                    x = curvePoints[i, 1];
                                    y = alglib.spline1dcalc(spline, x);
                                    points[i + 1] = new Point(x, y);
                                }
                            }

                            var dots = Curve.ToPointsGeometry(points, curveThickness * 3);

                            curvesCanvas.Children.Add(new PathShape
                            {
                                Data = dots,
                                Height = curveHeight,
                                Fill = curveColors[axis],
                                ClipToBounds = false,
                                IsHitTestVisible = false
                            });
                    }
#endif

#if false
                        //var maxErrors = yScales.Select(_ => 0.01D).ToArray();
                        //var (knotIndices, largestError) = Solvers.FitAkimaSplines(channelTitle, normalizedPoints, pointCount, dimension, maxErrors);

                        // Translation: quantize to 32-bit integer, in mm.
                        // allow 4-bits difference from curve => ±7.5mm

                        var maxError = curveKind switch
                        {
                            AnimationChannelTarget.PathEnum.translation => 0.1, // mm
                            AnimationChannelTarget.PathEnum.rotation => 0.01, // 1%
                            AnimationChannelTarget.PathEnum.scale => 0.001,
                            AnimationChannelTarget.PathEnum.weights => 0.001,
                            _ => throw new ArgumentOutOfRangeException()
                        };

                        var maxErrors = Enumerable.Range(0, dimension).Select(_ => maxError).ToArray();

                        var (knotIndices, largestError) = Solvers.FitAkimaSplines(curvesPoints, pointCount, dimension, maxErrors);

                        fittedKnotCounts.Append($"#{knotIndices.Count} {largestError}");

                        // TODO: This only works with a GLTF extension that supports Akima splines...
                        outputFloatCount += knotIndices.Count * (1 + dimension);

                        for (int axis = 0; axis < dimension; ++axis)
                        {
                            var inputPoints = visualPoints[axis];
                            var knotPoints = knotIndices.Select(i => inputPoints[i]).ToArray();

                            alglib.spline1dbuildakima(
                                knotPoints.Select(p => p.X).ToArray(),
                                knotPoints.Select(p => p.Y).ToArray(),
                                out var spline);

                            var fittedPoints = new Point[pointCount];

                            for (int i = 0; i < pointCount; ++i)
                            {
                                var x = inputPoints[i].X;
                                var y = alglib.spline1dcalc(spline, x);
                                fittedPoints[i] = new Point(x, y);
                            }

                            var line = Curve.ToLineGeometry(fittedPoints);

                            curvesCanvas.Children.Add(new PathShape
                            {
                                Data = line,
                                Height = curveHeight,
                                Stroke = curveColors[axis],
                                StrokeThickness = curveThickness * 2,
                                Opacity = 0.5,
                                ClipToBounds = false,
                                IsHitTestVisible = false
                            });

                            var dots = Curve.ToPointsGeometry(knotPoints, curveThickness * 3);

                            curvesCanvas.Children.Add(new PathShape
                            {
                                Data = dots,
                                Height = curveHeight,
                                Fill = curveColors[axis],
                                ClipToBounds = false,
                                IsHitTestVisible = false,
                                Opacity = 0.5
                            });
                        }
#endif

#if false
                        var quantRange = 1 << quantBits;

                        // Quantize values accessors

                        if (curveKind == AnimationChannelTarget.PathEnum.rotation)
                        {
                            for (var i = 0; i < valueFloats.Length; i++)
                            {
                                var f = Math.Round(valueFloats[i] * qScale) / qScale;
                                valueFloats[i] = (float)f;
                            }
                        }
#endif

#if false
                        for (int axis = 0; axis < dimension; ++axis)
                        {
                            // Quantize the curve points
                            var baseline = yMin[axis];
                            var encodedPoints = curvesPoints[axis]
                                .Select(p => new Point(p.X, (p.Y - baseline) * quantScale))
                                .ToArray();

                            if (encodedPoints.Any(p => p.Y < 0 || p.Y >= quantRange))
                                throw new ArgumentOutOfRangeException(channelTitle);

                            var (knotIndices, quantErrors) = Solvers.FitAkimaSpline(encodedPoints, quantError);

                            fittedKnotCounts.Append($"#{knotIndices.Count}");

                            var quantData = MemoryMarshal.AsBytes(new Span<sbyte>(quantErrors));
                            zipStream.Write(quantData);

                            // 8-bits per time (todo: fit per 256 samples)
                            // outputByteCount += knotIndices.Count * 5 + quantErrors.Length * quantError / 8;
                            outputByteCount += knotIndices.Count * 5;

                            var knotPoints = knotIndices.Select(i => encodedPoints[i]).ToArray();

                            alglib.spline1dbuildakima(
                                knotPoints.Select(p => p.X).ToArray(),
                                knotPoints.Select(p => p.Y).ToArray(),
                                out var spline);

                            var fittedPoints = new Point[pointCount];

                            for (int i = 0; i < pointCount; ++i)
                            {
                                var x = encodedPoints[i].X;
                                var y = Math.Round(alglib.spline1dcalc(spline, x));
                                y += quantErrors[i];
                                y /= quantScale;
                                y += baseline;
                                fittedPoints[i] = new Point(x, y);
                            }

                            for (var i = 0; i < pointCount; ++i)
                            {
                                valueFloats[i * dimension + axis] = (float)fittedPoints[i].Y;
                            }

                            var visualKnotPoints = knotIndices.Select(i => visualPoints[axis][i]).ToArray();

                            var yStart = yStarts[axis];
                            var yScale = yScales[axis];

                            var decodedPoints = fittedPoints
                                .Select((p, i) =>
                                {
                                    var x = xOffset + i * pixelsPerFrame;
                                    var y = yOffset + (p.Y - yStart) * yScale * yHeight;
                                    return new Point(x, y);
                                })
                                .ToArray();

                            var dots = Curve.ToPointsGeometry(decodedPoints, curveThickness * 1.5);

                            curvesCanvas.Children.Add(new PathShape
                            {
                                Data = dots,
                                Height = curveHeight,
                                Fill = curveColors[axis],
                                ClipToBounds = false,
                                IsHitTestVisible = false,
                                Opacity = 0.5
                            });

                            var line = Curve.ToLineGeometry(visualKnotPoints);

                            curvesCanvas.Children.Add(new PathShape
                            {
                                Data = line,
                                Height = curveHeight,
                                Stroke = curveColors[axis],
                                StrokeThickness = curveThickness * 2,
                                Opacity = 0.5,
                                ClipToBounds = false,
                                IsHitTestVisible = false
                            });

                            // var dots = Curve.ToPointsGeometry(knotPoints, curveThickness * 3);
                            //
                            // curvesCanvas.Children.Add(new PathShape
                            // {
                            //     Data = dots,
                            //     Height = curveHeight,
                            //     Fill = curveColors[axis],
                            //     ClipToBounds = false,
                            //     IsHitTestVisible = false,
                            //     Opacity = 0.5
                            // });
                        }
#endif

#if false
                        for (int axis = 0; axis < dimension; ++axis)
                        {
                            var cubicSegments = CubicRegression.FitCubics(visualPoints[axis], 8);
                            var cubicGeometry = CubicSegment.GetGeometry(cubicSegments);

                            fittedPointCounts.Append(cubicSegments.Count * 3 + 1);
                            fittedPointCounts.Append(' ');

                            curvesCanvas.Children.Add(new PathShape
                            {
                                Data = cubicGeometry,
                                Height = curveHeight,
                                Stroke = curveColors[axis],
                                StrokeThickness = curveThickness * 2,
                                Opacity = 0.5,
                                ClipToBounds = false,
                                IsHitTestVisible = false
                            });

                            var points = CubicSegment.GetPoints(cubicSegments).ToArray();

                            var dots = Curve.ToPointsGeometry(points, curveThickness * 3);

                            curvesCanvas.Children.Add(new PathShape
                            {
                                Data = dots,
                                Height = curveHeight,
                                Fill = curveColors[axis],
                                ClipToBounds = false,
                                IsHitTestVisible = false,
                                Opacity = 0.5,
                            });
                        }
#endif
